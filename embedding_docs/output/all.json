[
  {
    "id": 1,
    "content": "\n\n# Explore Edu Chain Ecosystem   \nBrowse and explore dapps from **DeFi**, **Infra** to **EDUFI**, and more, which are helping to \nbring education on-chain to **EDUCHAIN**.   \n \n## DApps List   \n \n| Name         | URL                          | Description | Category      | \n|--------------|------------------------------|-------------|---------------| \n| **SailFish** | [sailfish.finance](https://sailfish.finance/) | SailFish is the first DEX on \nOpencampus EDUCHAIN. Built to be fast and efficient, SailFish is a veDEX that distributes \n100% of protocol fees to users. | **DeFi** | \n| **MoveFlow** | [app.edu.moveflow.xyz](https://app.edu.moveflow.xyz/) | MoveFlow is the \nPayFi stack on EduChain, offering innovative streaming payment, buy now pay never solution for \nmanaging and optimizing on-chain payments for education. | **DeFi** | \n| **Blend**    | [app.blend.fan](https://app.blend.fan/) | Blend is a decentralised, non-custodial \nlending protocol on Educhain. | **DeFi** | \n| **Camelot**  | [app.camelot.exchange](https://app.camelot.exchange/) | Camelot is a \ndecentralized and permissionless exchange that supports the Arbitrum ecosystem with highly \nefficient liquidity infrastructure. | **DeFi** | \n| **GainzSwap** | [gainzswap.xyz](https://gainzswap.xyz/) | GainzSwap is a community-driven \ndecentralised exchange (DEX) designed to enhance sustained liquidity in DeFi. It features \ndynamic swapping fees, a deflationary Gainz token model, and governance through GToken. | \n**DeFi** | \n| **ThrustPad** | [thrustpad.finance](https://thrustpad.finance/) | ThrustPad is an innovative \nInitial Liquidity Offering (ILO) platform seamlessly built on the Educhain blockchain. Designed to \nempower projects and investors alike with a comprehensive suite of tools and services on their \nfundraising journey. | **Infrastructure** | \n| **EduScan**  | [eduscan.xyz](https://www.eduscan.xyz/) | EduScan is the best custom \nblockchain explorer for Educhain. It supports both mainnet & testnet. You can explore wallets, \ntransactions, blocks, tokens & the latest state data. | **Infrastructure** | \n| **Grasp Academy** | [grasp.academy](https://grasp.academy/) | Grasp is the premier \neducational content platform where educators and creators can share their work and earn on \nEDU Chain. Powered by Open Campus, the Grasp web3 platform integrates EduFi, enabling \nusers to learn, earn, and be rewarded for academic excellence. | **Infrastructure** | \n| **EduHub**   | [eduhub.dev](https://eduhub.dev/) | Building community and developer tools \nfor EDU Chain, so that anyone can quickly learn and ship awesome educational or any type of \ndApps on-chain. | **Infrastructure** | \n\n| **EduGPT**   | [ai.eduhub.dev](https://ai.eduhub.dev/) | EduGPT aims to simplify blockchain \ndata (AI Explorer) and build complex Web3 projects (For Developers). It explains everything in a \nsimple, fun way, helping you learn and build awesome projects quickly and easily on EduChain. \n| **Infrastructure** | \n| **Daily Wiser** | [dailywiser.xyz](http://dailywiser.xyz/) | Daily Wiser is an innovative mobile-\nfirst learning platform that transforms personal growth into an engaging daily habit. | \n**Education** | \n| **TinyTap**  | [campus.tinytap.com](https://campus.tinytap.com/) | TinyTap is a library of \neducational games for kids handmade by teachers, therapists, and education experts from all \nover the world. TinyTap is designed to help you turn playtime into a learning opportunity! | \n**Education** | \n| **Pody Network** | [pody.network](https://pody.network/) | Pody Network is a decentralized \nplatform built for virtual classrooms, offering interactive environments for education. Users \nengage in real-time learning while earning rewards for active participation. | **Education** | \n| **Proof of Learn** | [pol.solide0x.tech](https://pol.solide0x.tech/) | Proof of Learn is an \ninnovative online platform that ensures interactive, transparent, and verifiable learning across \n100+ blockchains, rewarding users with NFT POAPs for genuine engagement and \naccomplishment. | **Education** | ",
    "filename": "000.Ecosystem.pdf"
  },
  {
    "id": 2,
    "content": "\n\nGetting Started \nDetails about open campus here \nNetwork Details \nNetwork Attribute Value \nchainID 656476 \nSettlement Layer Arbitrum Sepolia 421614 \nRPC Url https://rpc.open-campus-codex.gelato.digital \nExplorer https://opencampus-codex.blockscout.com/ \nThe public summary of the network can be found at \nhttps://raas.gelato.network/rollups/details/public/open-campus-codex \nOverview of Docs \n• Open Campus Codex - Explains comprehensive insights into the architecture of \nOpen Campus Codex. \n• Build - Find all the resources you need to start testing, deploying, and interacting \nwith smart contracts on Open Campus Codex. \n• Services - Find all services deployed on Open Campus Codex and start levelling-\nup your applications. \n ",
    "filename": "1. Getting Started.pdf"
  },
  {
    "id": 3,
    "content": "\n\nWrite a Contract \nThis document explains how to automatically write any smart contract using the OpenZeppelin \nWizard. The resulting smart contract code can either be integrated with Remix by Clicking the \nOpen in Remix button, or copied to clipboard and pasted in the user's intended IDE. \nGetting Started  \nNavigate to the OpenZeppelin Wizard in your browser. First thing to notice is the Solidity Wizard \nand Cairo Wizard buttons. \nOne can choose any of the following tabs to begin creating an out-of-box smart contract code in \neither Solidity (for EVM chains) or Cairolang (useful for Starknet). These are: \n● ERC20: for writing an ERC-20 token smart contract \n● ERC721: for writing an NFT token smart contract \n● ERC1155: for writing an ERC-1155 token smart contract \n● Governor: for creating a DAO \n● Custom: for writing a customized smart contract \nWriting An NFT Contract  \nFor illustration purpose, we will be creating a NFT smart contract. Suppose you wanted to \ncreate a Mintable, Burnable ERC721 token and specify an appropriate license for it. \n1. Select the ERC721 tab. \n2. Give your NFT a name and a symbol by filling the Name and Symbol fields. \n3. Use the check-boxes on the left to select features of your token \n● Put a tick on the Mintable check-box \n● Put a tick on the Auto Increment Ids check-box, this ensures uniqueness of each minted \nNFT \n● Put a tick on the Burnable check-box \n● Either leave the default MIT license or type the license of your choice \nNotice that new lines of code are automatically written each time a feature is selected. \nVoila! Contract Ready  \nWith the resulting lines of code, you now have the NFT token contract written in Solidity. As \nmentioned above, this source code can now be ported to an IDE of your choice or opened \ndirectly in Remix. \nThe below figure depicts the auto-written NFT smart contract code. \n \n \n ",
    "filename": "10. Write a Contract.pdf"
  },
  {
    "id": 4,
    "content": "\n\nDeploy Using Hardhat \nHardhat is a popular smart contract development frameworks. In this tutorial, we will be using \nHardhat to deploy a simple Counter smart contract to the Custom Rollup Testnet. We will \nexplore the basics of creating a Hardhat project with a sample contract and a script to deploy it. \nFor the full instruction on how to use Hardhat, please refer to the official Hardhat documentation. \nCreate New Project  \nStart with creating an npm project by going to an empty folder, running npm init, and following its \ninstructions. You can use another package manager, like yarn, but Hardhat recommends you \nuse npm 7 or later, as it makes installing Hardhat plugins simpler. \nHardhat Smart Contract  \nTo create the sample project, run npx hardhat init in your project folder: \n● Press <ENTER> choose javascript, typescript or empty project \n● Press <ENTER> to set the project root \n● Press <ENTER> again to accept addition of .gitignore \n● Press <ENTER> to install hardhat @nomicfoundation/hardhat-toolbox \nCreate deployer account  \n● Create the .env file in your project root folder and add the following line: \nACCOUNT_PRIVATE_KEY='my private key' \n● Populate the .env file with your private key. You can get your private key from Metamask. \nSee the section below on how to get your private key from Metamask. \nHow to get your Private Key in Metamask \nwarning \nDo not commit your private key to a public repository! \nVerify that your .gitignore file contains .env to prevent your private key from being committed to \na public repository. \nConfigure Hardhat  \n● Open the hardhat.config.js file and paste the code below: \n● Javascript \n● Typescript \nrequire(\"dotenv\").config(); \nrequire(\"@nomicfoundation/hardhat-toolbox\"); \n \nmodule.exports = { \n\n solidity: \"0.8.19\", \n paths: { \n   artifacts: \"./src\", \n }, \n networks: { \n   opencampus: { \n     url: `https://rpc.open-campus-codex.gelato.digital/`, \n     accounts: [process.env.ACCOUNT_PRIVATE_KEY], \n   }, \n }, \n etherscan: { \n   apiKey: { \n     opencampus: \"your-etherscan-api-key\", \n   }, \n   customChains: [ \n     { \n       network: \"opencampus\", \n       chainId: 656476, \n       urls: { \n         apiURL: \"https://opencampus-codex.blockscout.com/api\", \n         browserURL: \"https://opencampus-codex.blockscout.com\", \n       }, \n     }, \n   ], \n }, \n}; \nWrite Smart Contract  \ninfo \nNote: The existing smart contract code that comes with the sample project is a Lock.sol \ncontract. Feel free to delete it or leave it. \n● Create a new file, in the contracts folder, named Counter.sol: \ntouch contracts/Counter.sol \n● Copy the below code and paste it in the Counter.sol contract code: \n//SPDX-License-Identifier: MIT \npragma solidity ^0.8.19; \n \ncontract Counter { \nuint256 currentCount = 0; \n \n   function increment() public { \n       currentCount = currentCount + 1; \n   } \n\n \n   function retrieve() public view returns (uint256){ \n       return currentCount; \n   } \n} \nCreate Deploy Script  \n● Delete the content of the scripts/deploy.js file and add the code below: \nconst hre = require(\"hardhat\"); \n \nasync function main() { \n const deployedContract = await hre.ethers.deployContract(\"Counter\"); \n await deployedContract.waitForDeployment(); \n console.log(`Counter contract deployed to ${deployedContract.target}`); \n} \n \nmain().catch((error) => { \n console.error(error); \n process.exitCode = 1; \n}); \nCompile Contract  \n● Install dotenv package: npm install dotenv \n● Compile your contract code (i.e., go back to the project root in the CLI), \n● npx hardhat compile \nDeploy Contract  \n● Run the deploy script: \n● npx hardhat run scripts/deploy.js --network opencampus \n \n \n ",
    "filename": "11. Deploy Using Hardhat.pdf"
  },
  {
    "id": 5,
    "content": "\n\nVerify Contracts \nOnce verified, a smart contract or token contract's source code becomes publicly available and \nverifiable, creating transparency and trust. \nThere are several ways to verify a contract, programmatically or manually on the UI. \nVerify on the UI  \n1. Go the the verify contract page (Other -> Verify Contract) \n2. Enter in the contract address you received during deployment. The dropdown will show \nyou several available verification options. Select the one you would like to use and \ncontinue. \ni. Solidity (Flattended source code) \nii. Solidity (Standard JSON Input) \n\nSolidity (Flattened Source Code)  \n \n1. Contract Address: The 0x address supplied on contract creation (added above) \n2. Is Yul Contract: Select if the contract is coded in Yul for efficiency. \n3. Include Nightly Builds: Select if you want to show nightly builds. \n4. Compiler: derived from the first line in the contract pragma solidity X.X.X. Use the \ncorresponding compiler version rather than the nightly build. \n5. EVM Version: Select the correct EVM version if known, otherwise use default. \n6. EVM Version: Select the correct EVM version if known, otherwise use default. \n7. Enter the Solidity Contract Code: You may need to flatten your solidity code if it utilizes a \nlibrary or inherits dependencies from another contract. We recommend hardhat or the \nPOA solidity flattener. To flatten your contract using contract, run: \nyarn hardhat flatten .\\contracts\\<your-contract>.sol > flattened.sol \n8. Add Contract Libraries: Enter the name and 0x address for any required libraries called \nin the .sol file. You can add multiple contracts with the \"+\" button. \n\n9. Click the Verify and Publish button. \n10. If all goes well, you will see a checkmark next to Code in the code tab, and an additional \ntab called Read Contract. The contract name will now appear in BlockScout with any \ntransactions related to your contract. \nSolidity (Standard JSON Input)  \n \n1. Include nightly builds. You can choose Yes or No depending on your compiler. \n2. Compiler. Choose the compiler version used to compile your smart contract. If you \nselected yes for nightly builds, use the compiler version rather than the build. \n3. Standard Input JSON. Upload your Standard Input JSON file. File should follows solidity \nformat and all the sources must be in Literal Content format, not a URL. \nClick the Verify & publish button and wait for the response. \nVerify Programmatically  \nTo verify contracts please follow the Verifying a Smart Contract guide to learn the different \noptions. \nIn particular, to be able to verify the contracts programatically we will need following steps: \n1- Install @nomiclabs/hardhat-etherscan package: \nyarn add --dev @nomiclabs/hardhat-etherscan \n2- Import into hardhat.config.ts \n\nimport \"@nomiclabs/hardhat-etherscan\"; \n3- Update hardhat.config.ts following: \n    apiKey: { \n     opencampus: \"XXX\", // no key required \n   }, \n   customChains: [ \n     { \n       network: \"opencampus\", \n       chainId: 656476, \n       urls: { \n         apiURL: \"https://opencampus-codex.blockscout.com/api\", \n         browserURL: \"https://opencampus-codex.blockscout.com/\", \n       }, \n     }, \n   ], \n4- Verify the contract Once the config is updated, you can verofy the contract with \nnpx hardhat verify --network opencampus YOUR-CONTRACT-ADDRESS \nYOUR-CONSTRUCTOR-ARGUMENTS \nEdit this page \n \n \n \n ",
    "filename": "12. Verify Contracts.pdf"
  },
  {
    "id": 6,
    "content": "\n\nOpen Campus ID Connect SDK \nWhere can i get it?  \nDownload it via npm here: https://www.npmjs.com/package/@opencampus/ocid-connect-js \nGithub documentation is here: https://github.com/opencampus-xyz/ocid-connect-js \nConnect OCID Button design (Figma) is here \nWhy do i need this?  \nTo integrate your product with the OpenCampus ecosystem, you need to retrieve and associate \nthe OCIDs of your users within your system. The \"Connect with OCID\" functionality works \nsimilarly to \"Login with Twitter\" or \"Login with Google.\" Our product suite provides a JavaScript \nSDK that you can integrate into your site, enabling users to log into OCID with a simple button \nclick. \nHow long does it work?  \nThis SDK provides an OAuth/OIDC interface to facilitate integration for our partners. \nJavascript-based SDK  \n● The SDK includes a JavaScript wrapper for our authentication APIs. \n● It also provides a set of React components for seamless integration into React \napplications. \n● Integration instructions are available in the package README on the public npm site. \nInteroperability  \n● The Connect with OCID APIs fully implement the OIDC standard, allowing developers to \nchoose custom integration with our authentication APIs. \n● We enforce the OIDC Code Flow with PKCE for enhanced security. \nDevelopment  \n● A Sandbox environment is available and can be easily activated in the SDK for \ndevelopment purposes. \n● The Sandbox environment does not require redirect_uri whitelisting, enabling developers \nto test their integrations before going live. \n\nConnecting to production  \nBy default, you will only be able to integrate with the “Sandbox” environment. To be whitelisted \nto interact with the production version, you will need to complete the following form! Make sure \nto give us the correct site link, as this will whitelist your app’s site at the domain level. \nThe form is here: App Whitelisting Form. \n \n \n ",
    "filename": "13. Open Campus ID Connect SDK.pdf"
  },
  {
    "id": 7,
    "content": "\n\nServices \nHere you will find common services and tools available to developers building dApps on the \nCustom Rollup, including sample configurations, and guides for many important elements of our \ninfrastructure, including: \n \n ",
    "filename": "14. Services.pdf"
  },
  {
    "id": 8,
    "content": "\n\nAccount Abstraction \nnote:Please note that this section is under active development. \nOverview  \nThe Ethereum blockchain network has two central types of accounts: externally owned accounts \n(EOAs) and contract accounts. EOAs are controlled by users; meanwhile, contract accounts are \nmanaged by smart contract code. Both account types are essential for the Ethereum \necosystem. However, EOAs are required to interact with the network, as they are the only way \nfor you to initiate transactions and execute smart contracts. \nThe problem with EOAs is their limitation to basic operations. And this restricts your options for \ninteracting with the Ethereum blockchain. For example \n● Poor Security: EOAs are secured by private keys, which are vulnerable to theft and loss. \n● Lack of customization: We must initiate transactions from EOAs, which means that we \ncan’t customize the transaction flow. For example, we can’t set up automatic payments \nor multi-factor authentication or define custom rules. \n● Gas Payment: Account must hold ETH to pay for gas fees. This is a significant barrier to \nentry for new users. \nWhat are the benefits of Account Abstraction?  \n● Increased Security: We manage conventional Ethereum accounts using seed phrases \nand private keys. This can be problematic if a user loses their seed phrase or \naccidentally leaks their private key. With account abstraction you’re given more \nopportunities to implement additional options for both account recovery and \nauthentication. \n● Improved User Experience: With account abstraction, we can create smart contract \nwallets that can be used to implement a wide range of features. For example, we can \ncreate wallets that automatically pay for gas fees, wallets that require multi-factor \nauthentication, and wallets that can be recovered using a social recovery mechanism. ",
    "filename": "15. Account Abstraction.pdf"
  },
  {
    "id": 9,
    "content": "\n\nSafe \nTo be updated when Safe Multisig app available on Open Campus. \n \n ",
    "filename": "16. Safe.pdf"
  },
  {
    "id": 10,
    "content": "\n\nZero Dev \nZeroDev is a smart, white-labeled, and modular embedded wallet for building user-friendly \nWeb3 experiences, particularly for DeFi applications. \nSmart: ZeroDev leverages account abstraction. White-labeled: ZeroDev doesn't have a UI -- it \nprovides the underlying wallet logic that you can build a totally customized experience on top of. \nModular: ZeroDev is built on top of Kernel, the most popular open-source smart account that \nsupports ERC-7579 plugins for customizing wallet logic. ZeroDev is one of the most trusted \nsolutions in AA, powering more than 50% of all AA wallets and a majority of DeFi volume that \nleverages AA. \nBefore starting please go ahead into ZeroDev Dashboard and create a project on Open \nCampus, so you will get a Project ID, \n \nPlease find a quickstart [here] \n \nWhen instantiating the react component please include bundlerProvider=\"GELATO\". \n <React.StrictMode> \n      <ZeroDevProvider \n           projectId={YOUR PROJECT ID} \n           bundlerProvider=\"GELATO\" \n         > \n       </ZeroDevProvider> \n \n </React.StrictMode> \n \n ",
    "filename": "17. Zero Dev.pdf"
  },
  {
    "id": 11,
    "content": "\n\nAutomation & Off-chain Data \nThe Problem  \nIn the realm of blockchain development, especially with decentralized applications (dApps), a \nsignificant challenge emerges in the form of limited auto-execution capabilities. Traditionally, \nsmart contracts, despite their advanced functionalities, lack the inherent ability to initiate or call \nmethods automatically. This limitation poses a hurdle in the seamless operation and scalability \nof blockchain applications. \nThe Solution  \nTo address this gap, automation solutions have been developed. These systems are designed \nto monitor both on-chain and off-chain data sources continuously. They are programmed to \nrecognize specific predefined conditions. Once these conditions are met, the automation system \nsprings into action, executing the necessary transactions without human intervention. \nUse cases  \n1. Auto Harvesting in DeFi: In decentralized finance applications, automation can manage \nyield farming strategies, harvesting rewards automatically when they reach a certain \nthreshold, thereby optimizing the return on investment for users. \n2. Limit Orders in Trading: Automated systems can execute trades when certain price \npoints are hit, mirroring the functionality of limit orders in traditional trading but within a \ndecentralized environment. \n \n ",
    "filename": "18. Automation.pdf"
  },
  {
    "id": 12,
    "content": "\n\nGelato Web3 Functions \nOverview  \nGelato's Web3 Functions is a powerful automation system designed to streamline and enhance \nWeb3 operations. Web3 Functions serve as a comprehensive tool, enabling developers to \neffortlessly set up, manage, and automate their smart contract tasks. Determining your Needs \nOff-chain Data or Computation? Sometimes, automation tasks require data that isn't readily \navailable on the blockchain, or they might need computations that are better performed \noff-chain. In such cases, Typescript Functions should be the choice. \nAll Checks On-chain? If all the conditions necessary for your automation task can be directly \nverified on the blockchain, you have the option to select between Typescript Functions, Solidity \nFunctions & Automated Transactions \nTriggers  \n1. Time Interval Description: Use this trigger to execute tasks at regular intervals, e.g., \nevery 10 minutes or once every 24 hours. It's like setting a straightforward, recurring \nalarm. \n2. Cron Expressions Description: This offers a more refined control compared to the Time \nInterval. With cron expressions, you can set tasks to run at specific moments, such as \n\"every Tuesday at 3 PM\" or \"on the 1st of every month\". It gives you precision in task \nscheduling. \n3. On-Chain Event Description: Ideal for those wanting their tasks to respond dynamically \nto blockchain activities. Whenever a specified event occurs on the blockchain, this \ntrigger springs your task into action. It's like a vigilant watcher, always ready to act. \n4. Every Block Description: This function operates with the rhythm of the blockchain itself, \nexecuting your chosen function each time a new block is created. \nWhat to Execute?  \nTypescript Functions  \nTypescript Functions are decentralized cloud functions that work similarly to AWS Lambda or \nGoogle Cloud, just for web3. They enable developers to execute on-chain transactions based \non arbitrary off-chain data (APIs / subgraphs, etc) & computation. These functions are written in \nTypescript, stored on IPFS and run by Gelato. \nSolidity Functions  \nSolidity Functions are crucial for making on-chain tasks automatic and more efficient. They \nconnect set conditions with specific actions in a smart contract, providing a straightforward \n\nmethod to turn user needs into automated processes. Consider them as a set of \"if-then\" rules: \nIf certain conditions are met on the blockchain, then a specific function gets executed. This level \nof automation ensures that the decentralized application can operate with minimal manual \nintervention, providing a seamless user experience. \nAutomated Transaction  \nAutomated Transaction ensures that a specific function on the target smart contract gets reliably \ntriggered. When you pre-define the inputs, it means that every time Gelato initiates the function \ncall, it uses consistent, predetermined arguments. \nQuick Start  \nWriting & Deploying Typescript Functions  \n1. Clone the hardhat-template repo \ngit clone web3-functions-hardhat-template \n2. CD into the folder and install \ncd web3-functions-hardhat-template && yarn install \n3. Update the index.ts in one of the examples \nWeb3Function.onRun(async (context: Web3FunctionContext) => { \n const { userArgs, multiChainProvider } = context; \n \n const provider = multiChainProvider.default(); \n // Retrieve Last oracle update time \n const oracleAddress = \n   (userArgs.oracle as string) ?? \"0x71B9B0F6C999CBbB0FeF9c92B80D54e4973214da\"; \n \n // YOUR CUSTOM LOGIC \n ..... \n \n // Return if nothing has to be pushed on-chain \n   return { canExec: false, message: `Coingecko call failed` }; \n \n // Return if tx has to be pushed on-chain \n return { \n   canExec: true, \n   callData: [ \n     { \n       to: oracleAddress, \n       data: oracle.interface.encodeFunctionData(\"updatePrice\", [price]), \n     }, \n   ], \n }; \n\n}); \n4. Deploy the Web3 Function to IPFS and create the Task \nnpx w3f deploy web3-functions/YOUR-FUNCTION/index.ts \nResult: \n$ npx w3f deploy web3-functions/YOUR-FUNCTION/index.ts \n✓ Web3Function deployed to ipfs. \n✓ CID: QmYMysfAhYYYrdhVytSTiE9phuoT49kMByktXSbVp1aRPx \n \nTo create a task that runs your Web3 Function every minute, visit: \n> \nhttps://beta.app.gelato.network/new-task?cid=QmYMysfAhYYYrdhVytSTiE9phuoT49kMByktXS\nbVp1aRPx \n✨  Done in 3.56s. \nFinally, go to the Gelato App, create a new task, decide on the trigger, and input the CID. \n \nWriting & Deploying Solidity Functions  \nThe central part of a solidity function is the Checker. A Checker acts as a bridge between \nconditions and smart contract executions. Its purpose? To check conditions and determine \nwhether a task should be executed by Gelato. Every checker returns two main things: \n● canExec (Boolean): Indicates if Gelato should execute the task. \n● execData (Bytes): Contains the data that executors will use during execution. \n\nOnce you have deployed your checker, go to the Gelato App, create a new task, decide the \ntrigger, and input the address of the checker contract and the method that does the check. \n \n ",
    "filename": "19. Gelato Web3 Functions.pdf"
  },
  {
    "id": 13,
    "content": "\n\nWhat is Open Campus? \nOpen Campus, also known as EDU Chain, is the first Layer 3 (L3) blockchain built \nspecifically for the education industry. It aims to leverage the traditional educational \nlandscape by bringing it on-chain, creating a secure and transparent ecosystem for all \neducational activities. \n• Educational Blockchain: The first of its kind L3 blockchain tailored for \neducational purposes. \n• Learn-to-Earn Ecosystem: A vibrant platform that links learning with earning, \nproviding real-world value to educational achievements. \n• Transparency and Security: Blockchain technology ensures that all educational \nrecords and transactions are secure, immutable, and transparent. \n• Trackable Learning Journey: Every educational milestone and achievement is \nrecorded on the blockchain, making it easy to track and verify progress. \n \n \n️ Arbitrum Orbit Overview \n️ Setup Codex RPC Node \n️ Block Explorer \n ",
    "filename": "2. What is Open Campus.pdf"
  },
  {
    "id": 14,
    "content": "\n\nBridges \nNote: Please note that this section is under active development. \nWhat is a Bridge?  \nBridges are a way to connect two different blockchains. They are a special type of smart \ncontract that allows you to lock up tokens on one blockchain and mint the same amount of \ntokens on another blockchain. This is a very useful feature, as it allows you to transfer tokens \nbetween different blockchains. For example, you can transfer tokens from the Ethereum \nblockchain to the Binance Smart Chain (BSC) blockchain. \n \n ",
    "filename": "20. Bridges.pdf"
  },
  {
    "id": 15,
    "content": "\n\nLayer Zero \nLayerZero is a messaging protocol, not a blockchain. Using smart contracts deployed on each \nchain, in combination with Decentralized Verifier Networks (DVNs) and Executors, LayerZero \nenables different blockchains to seamlessly interact with one another. \nGetting Started  \nTo start sending omnichain messages with LayerZero, you only need to implement two \nfunctions: \n \n● _lzSend: This function is used to send a message to a different chain. \n \n_lzSend( \n _dstEid, // the destination endpoint id \n _payload, // encoded message payload being sent \n _options, // message execution options \n MessagingFee(msg.value, 0), // the fee in native gas and ZRO token \n payable(msg.sender) // refund address in case of failed source message \n); \n● _lzReceive: This function is used to receive a message from a different chain. \n \nfunction _lzReceive( \n Origin calldata _origin, // struct containing srcEid, sender address, and the message nonce \n bytes32 _guid, // global message packet identifier \n bytes calldata payload, // encoded message being received \n address _executor, // the address of who executed the message \n bytes calldata _extraData // appended executor data for the call \n) internal override { \n data = abi.decode(payload, (string)); // your receive logic here \n} \n \nLayerZero offers Contract Standards that simplify this implementation by providing out of the \nbox message handling, interfaces for custom protocol configurations, and other quality of life \nimprovements: \n● OApp: the base contract standard for omnichain messaging and configuration. \n● OFT: the base contract standard for omnichain messaging and configuration. \nPrerequisites  \n1. You should first be familiar with writing and deploying contracts to your desired \nblockchains. This involves understanding the specific smart contract language and the \ndeployment process for those chains. \n\n2. A wallet set up and funded for the chains you'll be working with. \nDeploying your Contracts  \nnote \nThis example can be used with any EVM compatible chain. \nTo learn how to deploy your contracts, please refer to the Deploying Contracts section. \nTo checkout endpoint addresses please refer to the Endpoints section in the layerzero docs. \nConnecting your Contracts  \nTo connect your contracts, call setPeer and pass the address of your destination contract as a \nbytes32 value, as well as the destination endpoint ID. If successful, you now should be setup to \nstart sending cross-chain messages! \nTo go more in depth, please refer to the Getting Started section in the layerzero docs. \n \n ",
    "filename": "21. Layer Zero.pdf"
  },
  {
    "id": 16,
    "content": "\n\nIndexers \nUnderstanding Blockchain Indexing  \nBlockchain technology, often likened to a digital ledger, securely records data in encrypted \nblocks distributed across a decentralized network. Each block in the chain not only contains a \nrecord of new transactions but also carries information from the preceding block. However, due \nto blockchain's sequential structure, the associated data is dispersed across numerous blocks \nwithout an inherent system for identifying or extracting specific, higher-level data. \nBlockchain indexing steps in to address this. It allows users to efficiently search and filter \nthrough blockchain data, akin to how one might use Google, Bing, or other search engines to \nfind information on the internet. \nChallenges in Indexing Blockchain Data  \nIndexing data within a decentralized infrastructure like blockchain presents several obstacles: \n1. Absence of a Standard Query Language: Blockchain's immutable nature complicates \ndirect data reading, as it lacks a built-in query language similar to SQL in traditional \ndatabases. To access even basic information such as a user's transaction history, one \nwould have to examine each block individually. \n2. Complexities in Data Retrieval: The node structure of blockchains, particularly those akin \nto Ethereum, complicates data retrieval. Historical records are typically spread across \nvarious events and stored in separate sections of a node. Limited access to these \nevents in some public nodes can significantly slow down the query process. \n3. Limitations of Existing APIs: The APIs currently available are often restricted to basic \nqueries. These include range queries (such as records from a specific timeframe or a \ncertain number of transactions) and top-k queries (which rank different data points \nrelatively). This limitation hinders the ability to conduct more complex data analyses or \nsearches. \nSubgraphs: A Key Solution  \nOne of the most promising solutions to the challenges of indexing blockchain data is the use of \nsubgraphs. Subgraphs are essentially predefined data structures that are designed to efficiently \nindex and query data from a blockchain. \nWhat are Subgraphs?  \nSubgraphs are open-source APIs that allow developers to extract data from a blockchain and \nstore it in a structured format. They are designed to be flexible, allowing developers to define \nthe data they want to extract and how they want to store it. This flexibility enables subgraphs to \n\nbe used for a wide range of applications, from simple data retrieval to more complex data \nanalysis. \nAdvantages of Subgraphs  \n1. Customized Data Views: Developers can create subgraphs tailored to their specific \nneeds, focusing on the particular data they're interested in. \n2. Real-time Data Updates: Subgraphs can update their indexed data in real-time with each \nnew block on the blockchain, ensuring up-to-date information. \n3. Decentralized and Open: Like blockchains, subgraphs can be hosted in a decentralized \nmanner, promoting transparency and accessibility. \n \n ",
    "filename": "22. Indexers.pdf"
  },
  {
    "id": 17,
    "content": "\n\nGoldsky \nInstall + log in  \n1. Create an account at app.goldsky.com. \n2. Create an API key on the Settings page. \n3. Install the Goldsky CLI: \n4. curl https://goldsky.com | sh \n5. Log in with the API key created earlier: \n6. goldsky login \nBuild and deploy  \nDeploy your subgraph in one of four ways: \nBuild and deploy from source  \ncd <your-subgraph-directory> \ngraph build # Build your subgraph as normal. \ngoldsky subgraph deploy my-subgraph/1.0.0 \nBuild & Deploy from ABI and address  \ngoldsky subgraph deploy your-subgraph-name/your-version --from-abi <path-to-config-file> \nQuery Endpoint  \nAccess data by querying the endpoints. Use the following command to list all your subgraphs, \nand open the “GraphQL API” links that get printed in your browser to query your data in the \nGraphQL playground. \ngoldsky subgraph list \n \n \n ",
    "filename": "23. Goldsky.pdf"
  },
  {
    "id": 18,
    "content": "\n\nOracles \nOverview  \nBlockchain oracles are third-party services or agents that provide smart contracts with external \ninformation and serve as bridges between blockchains and the external world. Because \nblockchains cannot access external data (outside of their network) due to their secure and \ndeterministic nature, oracles are used to fetch, verify, and relay real-world data to smart \ncontracts in a way that's trustworthy. \nUse Cases  \nDecentalized Finance (DeFi)  \nOracles provide price feeds, enabling DeFi platforms to calculate token values, manage \ncollateral, and execute liquidations. By sourcing data from various exchanges and financial \nplatforms, oracles contribute to the robustness of DeFi applications. \nGaming  \nBlockchain-based gaming and betting platforms use oracles to determine the outcomes of \nevents, such as sports matches or random number generation. By connecting to various data \nsources and verifying results, oracles ensure fair and transparent gaming experiences. \nInsurance  \nOracles can be employed in the insurance industry to automate claims processing and \nunderwriting. They can fetch data related to weather conditions, flight delays, or health records, \nenabling insurers to create parametric insurance products. This reduces fraud and ensures \nquicker payouts based on predefined triggers. \nand much more... \n ",
    "filename": "24. Oracles.pdf"
  },
  {
    "id": 19,
    "content": "\n\nDIA \nDIA token price feeds provide smart contract real-time price information of 3,000+ \ncryptocurrencies, transparently sourced from 80+ trusted, high-volume DEXs and CEXs. \nThe feeds facilitate the development of DeFi use cases such as money markets, \nlending/borrowing, synthetic asset issuance, options, derivatives and futures markets, and many \nmore. \nHow to access DIA's oracle?  \nHere is an example of how to retrieve price value from a standard DIA oracle. For the purpose \nof this example, we will be using the following demo oracle on Ethereum: 0xa935...5856. \n1. Access any DIA oracle smart contract. \n2. Call getValue(pair_name) with pair_name being the full pair name such as BTC/USD. \nYou can use the \"Read\" section on Etherscan to execute this call. \n3. The response of the call contains four values: \n○ The current asset price in USD with a fix-comma notation of 8 decimals. \n○ the UNIX timestamp of the last update. \nOracle Integration Example  \nHere is an example on how you can integrate DIA's oracle into your smart contract with Solidity: \npragma solidity ^0.8.13; \n \ninterface IDIAOracleV2{ \n   function getValue(string memory) external returns (uint128, uint128); \n} \n \ncontract IntegrationSample{ \n \n   address immutable ORACLE = 0xa93546947f3015c986695750b8bbEa8e26D65856; \n   uint128 public latestPrice; \n   uint128 public timestampOflatestPrice; \n \n   function getPriceInfo(string memory key) external { \n       (latestPrice, timestampOflatestPrice) = IDIAOracleV2(ORACLE).getValue(key); \n   } \n \n   function checkPriceAge(uint128 maxTimePassed) external view returns (bool inTime){ \n        if((block.timestamp - timestampOflatestPrice) < maxTimePassed){ \n            inTime = true; \n        } else { \n\n            inTime = false; \n        } \n   } \n} \nFind more detailed description of the functions and how to run test in this GitHub repository \nDIA has a dedicated Solidity library to facilitate integration of DIA oracles in your own contracts. \nThe library consists of two functions, getPrice and getPriceIfNotOlderThan. You can learn more \nabout the library and how to use it in the DIA documentation. \n \n ",
    "filename": "25. DIA.pdf"
  },
  {
    "id": 20,
    "content": "\n\nRelay \nWhat is Relaying?  \nStandard Transactions  \nIn a standard Ethereum transaction, an ethereum user signs and sends the transaction \nthemselves. This user controls the private key to an externally owned account (EOA) which they \ncan use to sign a transaction and prove they have the right to spend the balance associated \nwith that account address. For each transaction a user sends, there is an associated transaction \nfee, known as gas. Since Ethereum executes computation, each unit of computation has an \nassociated gas cost, which deters malicious actors from overloading the network by requiring \nthem to pay heavily for a potential attack. This is excellent news for Ethereum's security and \nhelps keep the network consistent under load, but it comes at a hidden cost for onboarding new \nusers. \nOnboarding Issues  \nHow does a new user start interacting with exciting on-chain applications like DeFi, NFTs, or \ngaming? They will always need the native token to pay for gas on every network, even if the \nnetwork has very cheap gas fees like Polygon. This requires the user to open an account at a \ncentralised exchange, go through KYC, and buy crypto using fiat. This can be quite a process, \neven for the most skilled of degens out there, and it can deter new users from being onboarded \nto a dApp by increasing the latency between their initial excitement and the time it takes to \nactually get started. This is where relaying comes in! A relayer can help solve these issues by \nsending a transaction on behalf of the user. \nWhat is a Relayer?  \nWe allow the user to send a transaction without a native token balance (it turns out relayers can \nbe super nifty in loads of ways, for example, allowing a user who wants to swap a token to pay \nfor the gas using the token being swapped!). Ideally, we would also like to still utilise the \nexcellent security of a user signature, but for the transaction to be sent by a different EOA, one \ncontrolled by a relayer, who abstracts gas payment away from the user. This is a very import \ncontext shift to understand. We have shifted from a user signing and sending a transaction \nthemselves, to a user signing a standardised message and passing that on to a relayer. This \nrelayer will, first, verify the user's signature for security, and then pass their message along \non-chain. Gelato Relay does exactly this by taking a user's message off-chain and subsequently \nbuilding a meta-transaction which is executed on chain. \n\nMeta Transactions and EIP-712  \nA meta transaction is a regular ethereum transaction which contains the actual message to be \ndelivered on-chain to a target contract within itself, hence the term meta. The outer transaction \nhelps facilitate the first on-chain call which is sent by a relayer. The call is forwarded to the \ntarget contract using an intermediate smart contract (Gelato Relay), which in turn forwards the \ncall using the inner transaction to deliver the relayed message. \nTo achieve gasless transactions securely, Gelato Relay makes use of the EIP-712 standard. \nEIP-712 allows for a standardised way to sign and hash typed structured data. This means the \nuser can sign a message using their wallet without incurring a gas cost or interacting with the \nchain at all, and this signature can be verified on-chain, by the relayer, facilitating a gasless \ntransaction with security built in. This message will include important information such as the \ntransaction signer address, the target contract address, and the calldata payload used to target \na specific function. \n \n ",
    "filename": "26. Relay.pdf"
  },
  {
    "id": 21,
    "content": "\n\nGelato Relay \nIntroduction  \nUsing Gelato Relay, we relay your user's transactions on-chain, enabling secure gasless \ntransactions for an ultra-smooth UX for your app. This allows for a variety of new web3 \nexperiences, as the user can now pay by only signing a message, or their transaction costs can \nbe sponsored by the developer. As long as the gas costs are covered in one of the multiple \npayment methods that Gelato supports, we handle the rest reliably, quickly and securely. \n \nPrerequisites  \n● \"node\": \">=14.0.0\" \n● Basic JavaScript knowledge. \n● ethers knowledge \n\nGetting started  \n1: Installation  \nInstall the Gelato Relay SDK \nyarn add @gelatonetwork/relay-sdk \n2: Choose the Method  \nAt this point, you will need to answer the following questions, which will determine the method to \nuse when calling the Gelato Relay. \n● Do you require user authentication? When the use-case requires to authenticate the \noriginal user, you will need to implement the ERC2771 method where the user will sign \nthe payload, and the original user will be decoded on-chain from the callData replacing \nmsg.sender through _msgSender(), please see additional info here. \n● What is the funding strategy? When relaying a transaction, the Gelato Nodes are paying \nthe gas fees. There are two different ways of paying the fees back to Gelato. Either \ncreating a 1Balance account and deposit USDC on polygon that will pay for all of the \ntransactions on all EVM chains Gelato is deployed; or transferring back to gelato the \nfees while the transaction is executing, we call these methods syncFee, more info can \nbe found here, in this latter case, the target contract would need to inherit the \"Gelato \nRelay Context\" contracts, so the methods to query and transfer the fee to Gelato are \navailable. \nIf you require user authentication and you want to pay the transactions with a 1Balance account, \nthe method to use is the sponsoredCallERC2771. \nIf you require user authentication and you want every transaction to pay for itself, transferring by \nexecution the fees to Gelato, the method to use is the callWithSyncFeeERC2771. \nIf you don't require user authentication and you want to pay the transactions with a 1Balance \naccount, the method to use is the sponsoredCall. \nIf you don't require user authentication and you want every transaction to pay for itself, \ntransferring the fees by execution to Gelato, the method to use is the callWithSyncFee. \n3: Implementation  \nWe will require three simple steps to implement Gelato Relay. Here, we are going to showcase \nthe three steps required to implement the method sponsoredCallERC2771, which is the most \nused one. \nStep 1: Inherit Context Contract  \nDepending on the method, you must inherit different contracts as they will provide other \nmethods. In this case, we will have to inherit the ERC2771Context. The ERC2771Context \nprovide us with the methods _msgSender() and _msgData() that will allow us to recover the \noriginal user sending the transaction. \nimport { \n\n   ERC2771Context \n} from \"@gelatonetwork/relay-context/contracts/vendor/ERC2771Context.sol\"; \n \ncontract CounterERC2771 is ERC2771Context { \n \n   // ERC2771Context: setting the immutable trustedForwarder variable \n   constructor(address trustedForwarder) ERC2771Context(trustedForwarder) {} \n \n   function incrementContext() external { \n \n       // Incrementing the counter mapped to the _msgSender! \n       contextCounter[_msgSender()]++; \n \n       // Emitting an event for testing purposes \n       emit IncrementContextCounter(_msgSender()); \n   } \n} \nStep 2: Import the relay SDK  \nIn your frontend/backend, you would need to import and instantiate the relay class. \nimport { GelatoRelay, SponsoredCallERC2771Request } from \"@gelatonetwork/relay-sdk\"; \nconst relay = new GelatoRelay(API_KEY); \nStep 3: Send the payload to Gelato  \nThis is an example using Gelato's CounterERC2771.sol, which is deployed on these networks. \n// Set up on-chain variables, such as target address \nconst counter = \"0x00172f67db60E5fA346e599cdE675f0ca213b47b\"; \nconst abi = [\"function incrementContext()\"]; \nconst provider = new ethers.BrowserProvider(window.ethereum); \nconst signer = provider.getSigner(); \nconst user = signer.getAddress(); \n \n// Generate the target payload \nconst contract = new ethers.Contract(counter, abi, signer); \nconst { data } = await contract.incrementContext.populateTransaction(); \n \n// Populate a relay request \nconst request: CallWithERC2771Request = { \n chainId: (await provider.getNetwork()).chainId, \n target: counter; \n data: data; \n user: user; \n}; \n \n\n// Without a specific API key, the relay request will fail! \n// Go to https://relay.gelato.network to get a testnet API key with 1Balance. \n// Send a relay request using Gelato Relay! \nconst relayResponse = await relay.sponsoredCallERC2771(request, provider, apiKey); \nTracking your Request  \nWhen submitting your Gelato Relay requests, you'll receive a taskId in response. This taskId \nallows you to track the status of your request in two primary ways: \n1. WebSocket Subscriptions: This is the recommended and most efficient method. By \nsubscribing via WebSocket, the Gelato backend will automatically push updates for all \nyour tasks to your Relay SDK client. To start receiving these updates, you must register \na callback function, which will be triggered every time one of your tasks gets updated. \nDetailed implementation can be found here. \n2. Polling for Updates: Alternatively, you can periodically query the Gelato task status API \nfor updates. If you're using the Gelato Relay SDK, the getTaskStatus method makes this \neasy. Detailed implementation can be found here. \n \nto Relay \nIntroduction  \nUsing Gelato Relay, we relay your user's transactions on-chain, enabling secure gasless \ntransactions for an ultra-smooth UX for your app. This allows for a variety of new web3 \nexperiences, as the user can now pay by only signing a message, or their transaction costs can \nbe sponsored by the developer. As long as the gas costs are covered in one of the multiple \npayment methods that Gelato supports, we handle the rest reliably, quickly and securely. \n\n \nPrerequisites  \n● \"node\": \">=14.0.0\" \n● Basic JavaScript knowledge. \n● ethers knowledge \nGetting started  \n1: Installation  \nInstall the Gelato Relay SDK \nyarn add @gelatonetwork/relay-sdk \n2: Choose the Method  \nAt this point, you will need to answer the following questions, which will determine the method to \nuse when calling the Gelato Relay. \n● Do you require user authentication? When the use-case requires to authenticate the \noriginal user, you will need to implement the ERC2771 method where the user will sign \nthe payload, and the original user will be decoded on-chain from the callData replacing \nmsg.sender through _msgSender(), please see additional info here. \n\n● What is the funding strategy? When relaying a transaction, the Gelato Nodes are paying \nthe gas fees. There are two different ways of paying the fees back to Gelato. Either \ncreating a 1Balance account and deposit USDC on polygon that will pay for all of the \ntransactions on all EVM chains Gelato is deployed; or transferring back to gelato the \nfees while the transaction is executing, we call these methods syncFee, more info can \nbe found here, in this latter case, the target contract would need to inherit the \"Gelato \nRelay Context\" contracts, so the methods to query and transfer the fee to Gelato are \navailable. \nIf you require user authentication and you want to pay the transactions with a 1Balance account, \nthe method to use is the sponsoredCallERC2771. \nIf you require user authentication and you want every transaction to pay for itself, transferring by \nexecution the fees to Gelato, the method to use is the callWithSyncFeeERC2771. \nIf you don't require user authentication and you want to pay the transactions with a 1Balance \naccount, the method to use is the sponsoredCall. \nIf you don't require user authentication and you want every transaction to pay for itself, \ntransferring the fees by execution to Gelato, the method to use is the callWithSyncFee. \n3: Implementation  \nWe will require three simple steps to implement Gelato Relay. Here, we are going to showcase \nthe three steps required to implement the method sponsoredCallERC2771, which is the most \nused one. \nStep 1: Inherit Context Contract  \nDepending on the method, you must inherit different contracts as they will provide other \nmethods. In this case, we will have to inherit the ERC2771Context. The ERC2771Context \nprovide us with the methods _msgSender() and _msgData() that will allow us to recover the \noriginal user sending the transaction. \nimport { \n   ERC2771Context \n} from \"@gelatonetwork/relay-context/contracts/vendor/ERC2771Context.sol\"; \n \ncontract CounterERC2771 is ERC2771Context { \n \n   // ERC2771Context: setting the immutable trustedForwarder variable \n   constructor(address trustedForwarder) ERC2771Context(trustedForwarder) {} \n \n   function incrementContext() external { \n \n       // Incrementing the counter mapped to the _msgSender! \n       contextCounter[_msgSender()]++; \n \n       // Emitting an event for testing purposes \n       emit IncrementContextCounter(_msgSender()); \n\n   } \n} \nStep 2: Import the relay SDK  \nIn your frontend/backend, you would need to import and instantiate the relay class. \nimport { GelatoRelay, SponsoredCallERC2771Request } from \"@gelatonetwork/relay-sdk\"; \nconst relay = new GelatoRelay(API_KEY); \nStep 3: Send the payload to Gelato  \nThis is an example using Gelato's CounterERC2771.sol, which is deployed on these networks. \n// Set up on-chain variables, such as target address \nconst counter = \"0x00172f67db60E5fA346e599cdE675f0ca213b47b\"; \nconst abi = [\"function incrementContext()\"]; \nconst provider = new ethers.BrowserProvider(window.ethereum); \nconst signer = provider.getSigner(); \nconst user = signer.getAddress(); \n \n// Generate the target payload \nconst contract = new ethers.Contract(counter, abi, signer); \nconst { data } = await contract.incrementContext.populateTransaction(); \n \n// Populate a relay request \nconst request: CallWithERC2771Request = { \n chainId: (await provider.getNetwork()).chainId, \n target: counter; \n data: data; \n user: user; \n}; \n \n// Without a specific API key, the relay request will fail! \n// Go to https://relay.gelato.network to get a testnet API key with 1Balance. \n// Send a relay request using Gelato Relay! \nconst relayResponse = await relay.sponsoredCallERC2771(request, provider, apiKey); \nTracking your Request  \nWhen submitting your Gelato Relay requests, you'll receive a taskId in response. This taskId \nallows you to track the status of your request in two primary ways: \n1. WebSocket Subscriptions: This is the recommended and most efficient method. By \nsubscribing via WebSocket, the Gelato backend will automatically push updates for all \nyour tasks to your Relay SDK client. To start receiving these updates, you must register \na callback function, which will be triggered every time one of your tasks gets updated. \nDetailed implementation can be found here. \n\n2. Polling for Updates: Alternatively, you can periodically query the Gelato task status API \nfor updates. If you're using the Gelato Relay SDK, the getTaskStatus method makes this \neasy. Detailed implementation can be found here. \n \n ",
    "filename": "27. Gelato Relay.pdf"
  },
  {
    "id": 22,
    "content": "\n\nWallets \nOverview  \nWallet as a Service (WaaS) is essentially a modern solution for managing digital assets, tailored \nfor businesses and institutions. It's like having a digital wallet, but with advanced features and \nsecurity designed for professional use. \nAt its core, WaaS provides a secure and scalable way to handle cryptocurrencies and other \ndigital assets. It's designed to be flexible, catering to the needs of various businesses, \nregardless of their size. \nKey Features  \n1. Ease of Use and Security: It strikes a balance between being user-friendly and \nmaintaining high security, ensuring that managing digital assets is straightforward \nwithout compromising safety. \n2. Integration with Multiple Blockchains: WaaS allows for seamless connection with various \nblockchain networks. This means businesses can manage different types of digital \nassets across different blockchains all in one place. \n3. Key Recovery System: One of the challenges with digital wallets is the risk of losing \naccess keys. WaaS typically includes a system for recovering these keys, adding an \nextra layer of safety and peace of mind. \n4. Low-Cost Fees: It's designed to be cost-effective, minimizing the expenses associated \nwith digital asset management. \n \nWaaS offers a comprehensive digital wallet solution that addresses the main challenges of \nmodern digital asset management, combining ease of use, security, efficient blockchain \nintegration, a reliable key recovery system, and affordability. \n ",
    "filename": "28. Wallets-As-A-Service.pdf"
  },
  {
    "id": 23,
    "content": "\n\nPrivy \nThe Privy React SDK is the easiest way to onboard your users to web3 in your React App. \nWith just nine minutes of setup, you get out-of-the-box support for: \n● A variety of login methods, including email, phone, wallets, and social \n● Customizable UIs to progressively onboard your users \n● Self-custodial embedded wallets and powerful connectors for external wallets \nFor a Quickstart please visit here \nWhen using privy on Open Campus Testnet, please bear in mind that defaultChain and \nsupportedChainshave to be included in the chain config. \n<PrivyProvider \n appId=\"your-privy-app-id\" \n config={{ \n   // Customize Privy's appearance in your app \n   appearance: { \n     theme: 'light', \n     accentColor: '#676FFF', \n     logo: 'https://your-logo-url', \n   }, \n   // Create embedded wallets for users who don't have a wallet \n   embeddedWallets: { \n     createOnLogin: 'users-without-wallets', \n   }, \n \n   // Custom congif here \n       defaultChain: openCampusChain, \n       supportedChains: [openCampusChain], \n \n }} \n> \n</PrivyProvider> \n \n \n// OpenCampusChain definition here \nimport { defineChain } from \"viem-15\"; \nconst openCampusChain= defineChain ({ \n       id: 656476, \n       network: \"Open Campus Codex\", \n       name: \"Open Campus Codext\", \n       nativeCurrency: { \n           name: \"EDU\", \n           symbol: \"EDU\", \n           decimals: 18, \n\n       }, \n       rpcUrls: { \n           public: { \n               http: [\"https://rpc.open-campus-codex.gelato.digital\"], \n           }, \n           default: { \n               http: [\"https://rpc.open-campus-codex.gelato.digital\"], \n           }, \n       }, \n       blockExplorers: { \n           default: { \n               name: \"Block Scout\", \n               url: \"https://opencampus-codex.blockscout.com/\", \n           }, \n       }, \n       contracts: { \n       }, \n       testnet: true, \n   }), \n ",
    "filename": "29. Privy.pdf"
  },
  {
    "id": 24,
    "content": "\n\nArbitrum Orbit Overview \nArbitrum Orbit is an Optimistic rollup-based framework designed to empower web3 businesses \nby enabling the creation of custom, use case-specific Layer 2 (L2) or Layer 3 (L3) chains in a \npurely permissionless way. Orbit leverages the Arbitrum Nitro Tech stack, offering unparalleled \nscalability, advanced compression, full EVM compatibility, and soon-to-be-released cross-chain \ninteroperability. Essentially, Arbitrum Orbit can be thought of as deployable and configurable \ninstances of the Nitro stack, forming an ecosystem of independent chains. \nKey Features of Arbitrum Orbit  \n1. Customizable Throughput: Orbit chains provide dedicated throughput, ensuring high \nperformance and resource availability tailored to specific dApp requirements. \n2. EVM+ Compatibility: Support for multiple programming languages (Rust, C++, C, and \nSolidity) through Stylus, enabling flexible and cost-effective smart contract development. \n3. Predictable Gas Costs: Isolated transaction environments ensure stable and predictable \ngas fees, crucial for business cost forecasting. \n4. Broad Data Availability Options: Flexibility to choose data availability models, including \nEthereum Layer 1 or Data Availability Committees (DACs) for off-chain storage. \n5. Robust Security: Leveraging Ethereum's security and the Arbitrum Nitro tech stack \nensures a high level of security for Orbit chains. \n \nBy choosing Arbitrum Orbit, Open Campus leverages a powerful, flexible, and scalable \nblockchain solution that meets our unique needs. This partnership enables us to build an \ninnovative educational platform that redefines the Learn-to-Earn model, offering unparalleled \nbenefits to our users. \n \n \n ",
    "filename": "3. Arbitrum Orbit Overview.pdf"
  },
  {
    "id": 25,
    "content": "\n\nWeb3Auth \nWeb3Auth is a pluggable wallet infrastructure for Web3 wallets and applications. It streamlines \nthe onboarding of both mainstream and crypto native users in under a minute by providing \nexperiences that they're most comfortable with. With support for all OAuth-based login systems, \nweb & mobile native platforms, Web3Auth provides a seamless onboarding experience for your \nusers \nYou can follow a quick start guide here \nIn order to use Web3Auth on Open Campus testnet we will need to adapt the network config file \nto \n \nconst  chainConfig: { \n   chainNamespace: \"eip155\", \n   chainId: \"0xA045C\",// Cahin Id 656476 in hex \n   rpcTarget: \"https://rpc.open-campus-codex.gelato.digital\", \n   displayName: \"Open Campus Codex\", \n   blockExplorer: \"https://opencampus-codex.blockscout.com/\", \n   ticker: \"EDU\", \n   tickerName: \"EDU\", \n }, \n \n \n ",
    "filename": "30. Web3Auth.pdf"
  },
  {
    "id": 26,
    "content": "\n\nCommunity Forum \nWelcome to our Community Forum, a vibrant hub for developers, enthusiasts, and innovators in \nthe Web3 space. \nWhy Participate?  \n● Collaboration: Share ideas, collaborate on projects, and build together. \n● Support: Get answers to your queries and help others. \n● Stay Informed: Keep up with the latest trends and updates in Web3. \nGuidelines  \n● Respect: Maintain a respectful and constructive environment. \n● No Spam: Avoid promotional content unrelated to Web3. \n● Search First: Check if your question has already been answered. \nHow to Get Started  \n● Register: Sign up to participate in discussions. \n● Introduce Yourself: Let the community know about your interests and expertise. \n● Engage: Start discussions, share insights, and provide feedback. \nResources  \n● FAQ: Common questions and answers. \n● Documentation: In-depth guides and tutorials. \n● Community Guidelines \nJoin our community today and be a part of the Web3 revolution! \nForum Link \n \n ",
    "filename": "31. Community Forum.pdf"
  },
  {
    "id": 27,
    "content": "\n\nDeveloper Support \nWelcome to the Developer Support section, your go-to resource for technical assistance and \nguidance. \nWhat We Offer  \n● Technical Assistance: Expert support for your development queries and challenges. \n● Documentation: Comprehensive guides and API documentation. \n● Community Support: Access to a community of experienced Web3 developers. \nHow to Get Support  \n1. Browse Documentation: Find quick answers in our detailed documentation. \n2. Submit a Ticket: If you can't find an answer, submit a support ticket. \n3. Community Forums: Engage with the community for diverse perspectives. \nBest Practices  \n● Clear Descriptions: Provide detailed descriptions of your issues for quicker resolutions. \n● Include Code Snippets: Share relevant code snippets to clarify your queries. \n● Be Patient: Responses may take time due to the volume of inquiries. \n \nContact Support Developer Documentation \nWe're here to ensure your success in the Web3 ecosystem! \n \n \n ",
    "filename": "32. Developer Support.pdf"
  },
  {
    "id": 28,
    "content": "\n\nHow to Run a Full Node for an Orbit Chain \nThis section provides step-by-step instructions for running an Orbit node on your local machine. \nPrerequisites  \n● Latest Docker Image: offchainlabs/nitro-node:v2.3.4-b4cc111 \nMinimum Hardware Configuration  \n● RAM: 8-16 GB \n● CPU: 2-4 core CPU (e.g., AWS t3.xLarge) \n● Storage: Depends on the Orbit chain and its traffic over time \nRequired Parameters  \n1. Parent Chain Parameters  \nThe --parent-chain.connection.url argument requires a standard RPC endpoint for an EVM \nnode, whether self-hosted or obtained from a node service provider: \n--parent-chain.connection.url=<Parent chain RPC URL> \n2. Child Chain Parameters  \nIn the Arbitrum Orbit context, the child chain is an L2 or an L3 Orbit chain. The required \nparameters are chain.info-json and chain.name. \nchain.info-json A JSON string that contains required information about the Orbit chain. \n--chain.info-json=<Orbit Chain's chain info> \nchain.name A mandatory flag that needs to match the chain name used in --chain.info-json: \n--chain.name=<Orbit Chain's name> \n3. AnyTrust Chains For AnyTrust chains, add the following flags to the command or \nconfiguration: \n--node.data-availability.enable \n--node.data-availability.rest-aggregator.urls=<A list of DAS REST endpoints> \nOr \n--node.data-availability.rest-aggregator.online-url-list=<A URL that returns a list of the DAS \nREST endpoints> \n \n \n \n \n\n4. Important Ports  \nProtocol Port \nRPC/http 8547 \nRPC/websocket 8548 \nSequencer Feed 9642 \n \nFor the RPC/websocket protocol, use the following flags: \n--ws.port=8548 \n--ws.addr=0.0.0.0 \n--ws.origins=\\* \n5. Putting it all together  \nWhen running a Docker image, an external volume should be mounted to persist the database \nacross restarts. The mount point inside the Docker image should be /home/user/.arbitrum. \nExample: \ndocker run --rm -it -v /some/local/dir/arbitrum:/home/user/.arbitrum -p 0.0.0.0:8547:8547 -p \n0.0.0.0:8548:8548 offchainlabs/nitro-node:v2.3.4-b4cc111 --parent-chain.connection.url=<Parent \nchain RPC URL> --chain.id=<OrbitChainId> --chain.name=<My Arbitrum Orbit Chain> \n--http.api=net,web3,eth --http.corsdomain=* --http.addr=0.0.0.0 --http.vhosts=* \n--chain.info-json=<Orbit Chain's chain info> \n \nEnsure that /some/local/dir/arbitrum already exists; otherwise, the directory might be created \nwith root as the owner, and the Docker container won't be able to write to it. \nWhen using the flag --chain.info-json=<Orbit Chain's chain info>, replace <Orbit Chain's chain \ninfo> with the specific chain info JSON string of the Orbit chain for which you wish to run the \nnode. \n \nExample: \n    --chain.info-json=\"[{\\\"chain-id\\\":94692861356,\\\"parent-chain-id\\\":421614,\\\"chain-name\\\":\\\"My \nArbitrum L3 \nChain\\\",\\\"chain-config\\\":{\\\"chainId\\\":94692861356,\\\"homesteadBlock\\\":0,\\\"daoForkBlock\\\":null,\\\"d\naoForkSupport\\\":true,\\\"eip150Block\\\":0,\\\"eip150Hash\\\":\\\"0x00000000000000000000000000000\n00000000000000000000000000000000000\\\",\\\"eip155Block\\\":0,\\\"eip158Block\\\":0,\\\"byzantiumBl\nock\\\":0,\\\"constantinopleBlock\\\":0,\\\"petersburgBlock\\\":0,\\\"istanbulBlock\\\":0,\\\"muirGlacierBlock\\\":0,\n\\\"berlinBlock\\\":0,\\\"londonBlock\\\":0,\\\"clique\\\":{\\\"period\\\":0,\\\"epoch\\\":0},\\\"arbitrum\\\":{\\\"EnableArbOS\n\\\":true,\\\"AllowDebugPrecompiles\\\":false,\\\"DataAvailabilityCommittee\\\":false,\\\"InitialArbOSVersion\n\\\":10,\\\"InitialChainOwner\\\":\\\"0xAde4000C87923244f0e95b41f0e45aa3C02f1Bb2\\\",\\\"GenesisBloc\nkNum\\\":0}},\\\"rollup\\\":{\\\"bridge\\\":\\\"0xde835286442c6446E36992c036EFe261AcD87F6d\\\",\\\"inbox\\\n\n\":\\\"0x0592d3861Ea929B5d108d915c36f64EE69418049\\\",\\\"sequencer-inbox\\\":\\\"0xf9d77199288f\n00440Ed0f494Adc0005f362c17b1\\\",\\\"rollup\\\":\\\"0xF5A42aDA664E7c2dFE9DDa4459B927261BF\n90E09\\\",\\\"validator-utils\\\":\\\"0xB11EB62DD2B352886A4530A9106fE427844D515f\\\",\\\"validator-w\nallet-creator\\\":\\\"0xEb9885B6c0e117D339F47585cC06a2765AaE2E0b\\\",\\\"deployed-at\\\":1764099\n}}]\" \nFurther Reading  \nFor more detailed instructions and additional configuration options, please refer to the Arbitrum \ndocumentation here. \n \n \n ",
    "filename": "4. Setup Codex RPC Node.pdf"
  },
  {
    "id": 29,
    "content": "\n\nBlock Explorer \nThe Open Campus block explorer provides a comprehensive and user-friendly interface for \nmonitoring and analyzing network activities. It is designed to offer key insights and information \nbeneficial for both regular users and developers. Features of the Open Campus block explorer \ninclude: \n● Address Balances: Check the balance of any address on the network. \n● Transaction History: View detailed transaction records. \n● Verified Contracts: Access and review verified smart contract codes. \n● Smart Contract Code and Execution: Examine the code and execution details of smart \ncontracts. \n● Network Statistics: Get up-to-date information on network performance. \n● Mining Information: Monitor mining activities and related statistics. \n \nVisit the Open Campus Codex Block Explorer \n \n \n \n ",
    "filename": "5. Block Explorer.pdf"
  },
  {
    "id": 30,
    "content": "\n\nQuick Start \nOverview  \nOpen Campus is a Layer-3 solution enhancing Ethereum, providing an EVM-compatible \nenvironment for seamless integration. It utilizes advanced cryptographic techniques for \nefficiency and inherits Ethereum's security. \nConnecting to Codex  \nReminder \nOpen Campus Codex and its related documentation are under active development. \nAll feedback is welcome and highly appreciated. Please report errors or inconsistencies to a \nteam member or as an issue on our Issues Tracker, thank you. \nTo manually add the Open Campus Codex network to your wallet, use the following details: \n● Codex \nRPC URL ChainID Block Explorer \nURL \nCurrency \nhttps://rpc.open-campus-codex.gelato.di\ngital \n656476 Codex Block \nExplorer \nEDU \nTo add the network to MetaMask, you can either enter the data above manually or use the link \nprovided at the bottom of the Codex Block Explorer page. \nBridging Assets to Open Campus Codex Testnet  \nTo start interacting with the Open Campus Codex Testnet, you'll need to bridge your assets. \nBridging assets involves transferring cryptocurrencies from one blockchain (Arbitrum Sepolia) to \nanother (Open Campus Codex). This process expands your asset's utility by enabling its use \nwithin the Open Campus ecosystem. \nTo bridge your assets, follow the guide on asset bridging provided below. \nLearn more about bridging assets\n ↗ \nDeploying Smart Contracts on Codex  \nOpen Campus Codex provides a development environment that is designed to be familiar to \nthose who have worked with Ethereum. It allows developers to deploy smart contracts using \nexisting Ethereum tools and workflows, ensuring a smooth transition and a user experience \ncharacterized by higher throughput and reduced transaction costs. \n\nTo learn more about how to deploy your smart contracts to the Codex, refer to our \ncomprehensive guide below. \nDeploy Smart Contracts on Codex\n ↗ \nSupport Channels  \nFor support, developers can consult the community on platforms like StackExchange or join the \nofficial Discord server. \n \n ",
    "filename": "6. Quick Start.pdf"
  },
  {
    "id": 31,
    "content": "\n\nFaucet \nObtaining Testnet Tokens  \nTo acquire testnet tokens for network transactions, utilize the dRPC faucet that distributes \ntestnet ETH. Follow the verification process to receive your tokens. \nVerification Process  \nTo ensure fair and equitable access, you need to complete the following verification steps: \n1. dRPC Authorization \n○ Log in or create an account with dRPC. It's fast and free. \n2. Proof-of-Work \n○ This faucet requires mining for free testnet tokens to prevent abuse and spam. \nNote that the process of \"mining\" doesn't create new coins; it's just a time-limited \nmethod of protection. \nConnecting Wallet to Testnet  \nConfigure your wallet to connect to the Sepolia testnet where you can receive testnet ETH. \nUsing dRPC Faucet  \nAccess the dRPC faucet to obtain EDU: \n\n● dRPC Faucet \n \nOnce you have the EDU, you can proceed with testing and development on the Open Campus \nnetwork. \n \n ",
    "filename": "7. Faucet.pdf"
  },
  {
    "id": 32,
    "content": "\n\nAsset Bridging \nOverview  \nBridging assets to Open Campus is an essential process for users who wish to interact with the \nOpen Campus network. This section provides a comprehensive guide on how to bridge your \nassets effectively. \n● Direct Arbitrum Sepolia to Open Campus Codex Bridge: This is the primary method to \ntransfer assets directly from Arbitrum Sepolia to Open Campus Codex, which is essential \nfor executing transactions on Open Campus Codex. \nStep-by-Step Guide to Using the Official Bridge Portal  \n \n1. Visit the official Open Campus Bridge Portal and connect your wallet. \n2. Choose Arbitrum Sepolia as your source and Open Campus as the destination. \n3. Input the amount of assets you want to bridge. \n4. Confirm and sign the transaction with your wallet. \n\nWait for the bridging process to complete. The assets will then be available in your wallet on the \nre.al network. \nAfter the transaction is confirmed, the bridged assets will reflect in your Open Campus wallet, \nallowing you to interact with the network and its dApps. \nnote \nThe transaction times can vary based on network congestion and gas fees. Please ensure you \nhave enough ETH in your wallet to cover the transaction fees. \n \n ",
    "filename": "8. Asset Bridging.pdf"
  },
  {
    "id": 33,
    "content": "\n\nSmart Contracts \n \n ",
    "filename": "9. Smart Contracts.pdf"
  },
  {
    "id": 34,
    "content": "\n\nLearn About Open Campus Network \nExplains comprehensive insights into the architecture of Codex. \n ",
    "filename": "Learn About Open Campus Network.pdf"
  }
]